@inproceedings{henrix_gin_2012,
	address = {Berlin, Heidelberg},
	title = {{GiN}: {A} {Graphical} {Language} and {Tool} for {Defining} {iTask} {Workflows}},
	isbn = {978-3-642-32037-8},
	abstract = {Workflow Management Systems (WFMSs) are software applications that coordinate business processes. The coordination is based on a workflow model, expressed in a domain-specific Workflow Description Language (WDL). WDLs are typically graphical languages because the specification has to be understandable for domain experts as well as workflow application developers. Commonly, only simple workflows can be described while additional coding is needed to turn the description into a running application. The iTask system is a combinator library, embedded in Clean, to construct WFMSs. Complex workflows can be defined declaratively from which a complete web-based application is generated. However, the textual specification is less suitable for domain experts who are used to graphical notations. In this paper we address this problem and present GiN: a graphical notation for iTask workflows, as well as a prototype implementation of a tool to construct GiN workflows interactively and graphically. The tool is fully integrated in the iTask system: it is just another iTask component, and workflows created with GiN can be subsequently added and executed dynamically as part of other workflows.},
	booktitle = {Trends in {Functional} {Programming}},
	publisher = {Springer Berlin Heidelberg},
	author = {Henrix, Jeroen and Plasmeijer, Rinus and Achten, Peter},
	editor = {Peña, Ricardo and Page, Rex},
	year = {2012},
	pages = {163--178},
	file = {Henrix et al. - 2012 - GiN A Graphical Language and Tool for Defining iT.pdf:/home/mrl/Zotero/storage/CZ9U2CG5/Henrix et al. - 2012 - GiN A Graphical Language and Tool for Defining iT.pdf:application/pdf},
}

@incollection{plasmeijer_itask_2009,
	address = {Berlin, Heidelberg},
	title = {An {iTask} {Case} {Study}: {A} {Conference} {Management} {System}},
	isbn = {978-3-642-04652-0},
	abstract = {Workflow systems are automated systems in which tasks are coordinated by assigning them to either humans or computers. Contemporary workflow systems are static and not very flexible. In these lecture notes, we discuss the iTask system: a combinator library for specifying workflows in the functional language Clean. This system offers several advantages when compared to commercial systems: tasks are statically typed, tasks can be higher order, the combinators are fully compositional, and dynamic and recursive workflow can be specified. Moreover, the specification is an executable specification offering a web-based multi-user workflow system. In this paper we describe the iTask system using a conference management system as the running example to illustrate the expressive power of functional and generic programming in a real-world domain.},
	booktitle = {Advanced {Functional} {Programming}: 6th {International} {School}, {AFP} 2008, {Heijen}, {The} {Netherlands}, {May} 2008, {Revised} {Lectures}},
	publisher = {Springer Berlin Heidelberg},
	author = {Plasmeijer, Rinus and Achten, Peter and Koopman, Pieter and Lijnse, Bas and van Noort, Thomas},
	editor = {Koopman, Pieter and Plasmeijer, Rinus and Swierstra, Doaitse},
	year = {2009},
	doi = {10.1007/978-3-642-04652-0_7},
	pages = {306--329},
	file = {Plasmeijer et al. - 2009 - An iTask Case Study A Conference Management Syste.pdf:/home/mrl/Zotero/storage/3AK3YV4K/Plasmeijer et al. - 2009 - An iTask Case Study A Conference Management Syste.pdf:application/pdf},
}

@inproceedings{lijnse_itasks_2009,
	title = {{iTasks} 2: {iTasks} for {End}-users},
	booktitle = {International {Symposium} on {Implementation} and {Application} of {Functional} {Languages}},
	publisher = {Springer},
	author = {Lijnse, Bas and Plasmeijer, Rinus},
	year = {2009},
	pages = {36--54},
	file = {Lijnse and Plasmeijer - 2009 - iTasks 2 iTasks for End-users.pdf:/home/mrl/Zotero/storage/KACEWKXY/Lijnse and Plasmeijer - 2009 - iTasks 2 iTasks for End-users.pdf:application/pdf},
}

@inproceedings{lijnse_incidone:_2012,
	title = {Incidone: {A} task-oriented incident coordination tool},
	volume = {12},
	booktitle = {Proceedings of the 9th {International} {Conference} on {Information} {Systems} for {Crisis} {Response} and {Management}, {ISCRAM}},
	author = {Lijnse, Bas and Jansen, Jan Martin and Plasmeijer, Rinus and {others}},
	year = {2012},
	file = {Lijnse et al. - 2012 - Incidone A task-oriented incident coordination to.pdf:/home/mrl/Zotero/storage/EYS9U69B/Lijnse et al. - 2012 - Incidone A task-oriented incident coordination to.pdf:application/pdf},
}

@incollection{achten_why_2013,
	address = {Berlin, Heidelberg},
	title = {Why {Functional} {Programming} {Matters} to {Me}},
	volume = {8106},
	isbn = {978-3-642-40354-5 978-3-642-40355-2},
	abstract = {Functional programming advocates a style of programming in which the programmer seeks to ﬁnd a suﬃciently small, yet powerful, set of abstractions that capture an entire class of problems, and use these abstractions to solve a concrete problem. I illustrate this by means of a case study in which I implement the game Trax TM . In this turn-based game two players attempt to create either a closed loop of a line of their own color, or make the line connect opposite ends of a tile set of some prescribed minimal dimensions. Trax TM is an attractive case because it has interesting computational problems, for which I use classical functional techniques, but also because it is a distributed multi-user application, for which I use the more recently developed iTask formalism.},
	language = {en},
	urldate = {2019-01-14},
	booktitle = {The {Beauty} of {Functional} {Code}},
	publisher = {Springer Berlin Heidelberg},
	author = {Achten, Peter},
	editor = {Achten, Peter and Koopman, Pieter},
	year = {2013},
	doi = {10.1007/978-3-642-40355-2_7},
	pages = {79--96},
	file = {Achten - 2013 - Why Functional Programming Matters to Me.pdf:/home/mrl/Zotero/storage/QJDP95KG/Achten - 2013 - Why Functional Programming Matters to Me.pdf:application/pdf},
}

@inproceedings{achten_task_2014,
	title = {Task oriented programming with purely compositional interactive scalable vector graphics},
	booktitle = {Proceedings of the 26nd 2014 {International} {Symposium} on {Implementation} and {Application} of {Functional} {Languages}},
	publisher = {ACM},
	author = {Achten, Peter and Stutterheim, Jurriën and Domoszlai, László and Plasmeijer, Rinus},
	year = {2014},
	pages = {7},
	file = {Achten et al. - 2014 - Task oriented programming with purely compositiona.pdf:/home/mrl/Zotero/storage/D6VP4YKS/Achten et al. - 2014 - Task oriented programming with purely compositiona.pdf:application/pdf},
}

@inproceedings{stutterheim_tonic:_2014,
	title = {Tonic: {An} infrastructure to graphically represent the definition and behaviour of tasks},
	booktitle = {International {Symposium} on {Trends} in {Functional} {Programming}},
	publisher = {Springer},
	author = {Stutterheim, Jurriën and Plasmeijer, Rinus and Achten, Peter},
	year = {2014},
	pages = {122--141},
	file = {Stutterheim et al. - 2014 - Tonic An infrastructure to graphically represent .pdf:/home/mrl/Zotero/storage/GUGYH5FN/Stutterheim et al. - 2014 - Tonic An infrastructure to graphically represent .pdf:application/pdf},
}

@inproceedings{oortgiese_distributed_2017,
	address = {New York, NY, USA},
	title = {A {Distributed} {Dynamic} {Architecture} for {Task} {Oriented} {Programming}},
	booktitle = {Proceedings of the 29th {Symposium} on {Implementation} and {Application} of {Functional} {Programming} {Languages}},
	publisher = {ACM},
	author = {Oortgiese, Arjan and van Groningen, John and Achten, Peter and Plasmeijer, Rinus},
	year = {2017},
	note = {event-place: Bristol, UK},
	pages = {7},
	file = {Oortgiese et al. - 2017 - A Distributed Dynamic Architecture for Task Orient.pdf:/home/mrl/Zotero/storage/5E2PKYH6/Oortgiese et al. - 2017 - A Distributed Dynamic Architecture for Task Orient.pdf:application/pdf},
}

@incollection{wang_maintaining_2018,
	address = {Cham},
	title = {Maintaining {Separation} of {Concerns} {Through} {Task} {Oriented} {Software} {Development}},
	volume = {10788},
	isbn = {978-3-319-89718-9},
	abstract = {Task Oriented Programming is a programming paradigm that enhances ‘classic’ functional programming with means to express the coordination of work among people and computer systems, the distribution and control of data sources, and the human-machine interfaces. To make the creation process of such applications feasible, it is important to have separation of concerns. In this paper we demonstrate how this is achieved within the Task Oriented Software Development process and illustrate the approach by means of a case study.},
	language = {en},
	urldate = {2019-01-14},
	booktitle = {Trends in {Functional} {Programming}},
	publisher = {Springer International Publishing},
	author = {Stutterheim, Jurriën and Achten, Peter and Plasmeijer, Rinus},
	editor = {Wang, Meng and Owens, Scott},
	year = {2018},
	doi = {10.1007/978-3-319-89719-6},
	pages = {19--38},
	file = {Stutterheim et al. - 2018 - Maintaining Separation of Concerns Through Task Or.pdf:/home/mrl/Zotero/storage/4GXJEM2U/Stutterheim et al. - 2018 - Maintaining Separation of Concerns Through Task Or.pdf:application/pdf},
}

@inproceedings{plasmeijer_task-oriented_2012,
	address = {New York, NY, USA},
	series = {{PPDP} '12},
	title = {Task-{Oriented} {Programming} in a {Pure} {Functional} {Language}},
	isbn = {978-1-4503-1522-7},
	doi = {10.1145/2370776.2370801},
	abstract = {Task-Oriented Programming (TOP) is a novel programming paradigm for the construction of distributed systems where users work together on the internet. When multiple users collaborate, they need to interact with each other frequently. TOP supports the definition of tasks that react to the progress made by others. With TOP, complex multi-user interactions can be programmed in a declarative style just by defining the tasks that have to be accomplished, thus eliminating the need to worry about the implementation detail that commonly frustrates the development of applications for this domain. TOP builds on four core concepts: tasks that represent computations or work to do which have an observable value that may change over time, data sharing enabling tasks to observe each other while the work is in progress, generic type driven generation of user interaction, and special combinators for sequential and parallel task composition. The semantics of these core concepts is defined in this paper. As an example we present the iTask3 framework, which embeds TOP in the functional programming language Clean.},
	booktitle = {Proceedings of the 14th {Symposium} on {Principles} and {Practice} of {Declarative} {Programming}},
	publisher = {ACM},
	author = {Plasmeijer, Rinus and Lijnse, Bas and Michels, Steffen and Achten, Peter and Koopman, Pieter},
	year = {2012},
	note = {event-place: Leuven, Belgium},
	keywords = {clean, task-oriented programming},
	pages = {195--206},
	file = {103802.pdf:/home/mrl/Zotero/storage/ZE6A65AW/103802.pdf:application/pdf},
}

@inproceedings{domoszlai_editlets_2014,
	address = {New York, NY, USA},
	series = {{IFL} '14},
	title = {Editlets: type-based, client-side editors for {iTasks}},
	isbn = {978-1-4503-3284-2},
	doi = {10.1145/2746325.2746331},
	abstract = {The iTask framework enables the construction of distributed systems where users work together on the internet. It offers a domain specific language for defining applications, embedded in the lazy functional language Clean. From the mere declarative specification of the tasks to do and their interconnection, a multi-user web application is generated which can coordinate the work thus described. User interfaces are generated automatically which is realized by using type-driven generic functions. Although this way of generating user interfaces entails a number of benefits for the programmer, it suffers from the lack of possibility to create custom user interface building blocks. In a precursory work we proposed tasklets for the development of custom, interactive web components. However, experimenting with real-world applications indicated that they lack some fundamental properties limiting their usability; these are the tight integration with the type-driven user interface generation, and the capability of working with shared data. In this paper, we introduce editlets to overcome these limitations. In addition, editlets also provide a general way to communicate changes instead of exchanging the whole data to reduce communication overhead.},
	booktitle = {Proceedings of the 26nd 2014 {International} {Symposium} on {Implementation} and {Application} of {Functional} {Languages}},
	publisher = {Association for Computing Machinery},
	author = {Domoszlai, László and Lijnse, Bas and Plasmeijer, Rinus},
	year = {2014},
	note = {event-place: Boston, MA, USA},
	keywords = {change based synchronization, editlet, iTasks},
	file = {PDF:/home/mrl/Zotero/storage/RUMSU4QM/Domoszlai et al. - 2014 - Editlets type-based, client-side editors for iTasks.pdf:application/pdf},
}
@incollection{domoszlai_tasklets_2015,
	address = {Cham},
	title = {Tasklets: {Client}-{Side} {Evaluation} for {iTask3}},
	isbn = {978-3-319-15940-9},
	abstract = {iTask3 is the most recent incarnation of the iTask framework for the construction of distributed systems where users work together on the internet. It offers a domain specific language for defining applications, embedded into the lazy functional language Clean. From the mere declarative specification a complete multi-user web application is generated. Although the generated nature of the user interface (UI) entails a number of benefits for the programmer, it suffers from the lack of possibility to create custom UI building blocks. In this paper, we present an extension to the iTask3 framework which introduces the concept of tasklets for the development of custom, interactive web components in a single language manner. We further show that the presented tasklet architecture can be generalized in such a way that arbitrary parts of an iTask application can be executed on the client.},
	booktitle = {Central {European} {Functional} {Programming} {School}: 5th {Summer} {School}, {CEFP} 2013, {Cluj}-{Napoca}, {Romania}, {July} 8-20, 2013, {Revised} {Selected} {Papers}},
	publisher = {Springer International Publishing},
	author = {Domoszlai, László and Plasmeijer, Rinus},
	editor = {Zsók, Viktória and Horváth, Zoltán and Csató, Lehel},
	year = {2015},
	doi = {10.1007/978-3-319-15940-9_11},
	pages = {428--445},
	file = {10.1007_978-3-319-15940-9_11-citation:/home/mrl/Zotero/storage/WTBC47CU/10.1007_978-3-319-15940-9_11-citation.bib:text/x-bibtex;PDF:/home/mrl/Zotero/storage/7IT8JN4C/tasklet.pdf:application/pdf},
}
@incollection{domoszlai_clean_2013,
	address = {Berlin, Heidelberg},
	title = {Clean {Up} the {Web}!},
	isbn = {978-3-642-40355-2},
	abstract = {Programming in Clean is much more appealing than programming in JavaScript. Therefore, solutions that can replace JavaScript with Clean in client-side web development are widely welcomed. This paper describes a technology for the cross-compilation of Clean to JavaScript and for the tight integration of the generated code into a web application. Our solution is based on the iTask framework and its extension, the so-called Tasklets. The application server approach provides simple and easy deployment, thus supporting rapid development. Examples are shown to illustrate how communication between the Clean and JavaScript code can be established.},
	booktitle = {The {Beauty} of {Functional} {Code}: {Essays} {Dedicated} to {Rinus} {Plasmeijer} on the {Occasion} of {His} 61st {Birthday}},
	publisher = {Springer Berlin Heidelberg},
	author = {Domoszlai, László and Kozsik, Tamás},
	editor = {Achten, Peter and Koopman, Pieter},
	year = {2013},
	doi = {10.1007/978-3-642-40355-2_10},
	pages = {133--150},
	file = {PDF:/home/mrl/Zotero/storage/T2CFX4RQ/Domoszlai and Kozsik - 2013 - Clean Up the Web!.pdf:application/pdf},
}

@misc{top_software_viia_2023,
	title = {{VIIA} ({Vessel} {Information} {Integrating} {Application})},
	url = {https://www.top-software.nl/VIIA.html},
	urldate = {2023-02-06},
	author = {TOP Software},
	year = {2023},
}

@incollection{lijnse_evolution_2013,
	address = {Berlin, Heidelberg},
	title = {Evolution of a {Parallel} {Task} {Combinator}},
	isbn = {978-3-642-40355-2},
	abstract = {The development of experimental software is rarely straightforward. If you start making something you don't understand yet, it is very unlikely you get it right at the first try. The iTask system has followed this predictably unpredictable path. In this system, where combinator functions are used to construct interactive workflow support systems, the core set of combinator functions has changed along with progressed understanding of the domain. Continuous work on this system led to the emergence of a new programming paradigm for interactive systems: Task-Oriented Programming (TOP). In this paper we reconstruct the evolution of one of the core iTasks combinators to catch a glimpse of this emergence. The combinator is the parallel combinator that facilitates the composition of multiple concurrent tasks into a single one. We reconstruct its evolution from the written record in the form of published papers and discuss this reconstruction and what it tells about the progressed understanding of programming with tasks.},
	booktitle = {The {Beauty} of {Functional} {Code}: {Essays} {Dedicated} to {Rinus} {Plasmeijer} on the {Occasion} of {His} 61st {Birthday}},
	publisher = {Springer Berlin Heidelberg},
	author = {Lijnse, Bas},
	editor = {Achten, Peter and Koopman, Pieter},
	year = {2013},
	doi = {10.1007/978-3-642-40355-2_14},
	pages = {193--210},
	file = {Lijnse - 2013 - Evolution of a Parallel Task Combinator.pdf:/home/mrl/Zotero/storage/WDZE9X5G/Lijnse - 2013 - Evolution of a Parallel Task Combinator.pdf:application/pdf},
}

@inproceedings{steenvoorden_dynamic_2024,
	address = {New York, NY, USA},
	series = {{IFL} '23},
	title = {Dynamic {TopHat}: {Start} and {Stop} {Tasks} at {Runtime}},
	isbn = {9798400716317},
	doi = {10.1145/3652561.3652574},
	abstract = {TopHat is a mathematically formalized language for Task-Oriented Programming (top). It allows developers to specify workflows and business processes in a formal language, reason about their equality and use symbolic execution to verify their correctness and generate next-step hints. TopHat can run workflow specifications supporting collaborators during their execution. However, it can only do so for a statically specified amount of work. That is, the number of tasks running in parallel is always predefined by the developer. In contrast, other top engines like iTasks and mTasks act like an operating system, starting and stopping tasks at will. To capture this dynamic nature of workflow systems, we introduce Dynamic TopHat: a moderate extension to the TopHat calculus which allows end-users to initialize and kill tasks at runtime. Although this is a restricted version of the dynamic task lists found in iTasks, where the system itself can initialize new tasks, we show that common use cases of this feature are still expressible in Dynamic TopHat. Also, our proposed solution does not compromise the formal reasoning properties of TopHat. TopHat’s metatheory is formalized in the dependently typed programming language Idris and its symbolic execution engine is implemented in Haskell.},
	booktitle = {Proceedings of the 35th {Symposium} on {Implementation} and {Application} of {Functional} {Languages}},
	publisher = {Association for Computing Machinery},
	author = {Steenvoorden, Tim and Naus, Nico},
	year = {2024},
	note = {event-place: Braga, Portugal},
	keywords = {formal semantics, functional programming, symbolic execution, Task-oriented programming},
	file = {PDF:/home/mrl/Zotero/storage/XFEYPQGG/Steenvoorden and Naus - 2024 - Dynamic TopHat Start and Stop Tasks at Runtime.pdf:application/pdf},
}

@article{plasmeijer_itasks:_2007,
	title = {{iTasks}: executable specifications of interactive work flow systems for the web},
	volume = {42},
	number = {9},
	journal = {ACM SIGPLAN Notices},
	author = {Plasmeijer, Rinus and Achten, Peter and Koopman, Pieter},
	year = {2007},
	pages = {141--152},
	file = {plar2007-ICFP07-iTasks.pdf:/home/mrl/Zotero/storage/N8EUZP7D/plar2007-ICFP07-iTasks.pdf:application/pdf},
}

@article{lubbers_could_2023,
	title = {Could {Tierless} {Languages} {Reduce} {IoT} {Development} {Grief}?},
	volume = {4},
	issn = {2691-1914},
	url = {https://doi.org/10.1145/3572901},
	doi = {10.1145/3572901},
	abstract = {Internet of Things (IoT) software is notoriously complex, conventionally comprising multiple tiers. Traditionally an IoT developer must use multiple programming languages and ensure that the components interoperate correctly. A novel alternative is to use a single tierless language with a compiler that generates the code for each component and ensures their correct interoperation.We report a systematic comparative evaluation of two tierless language technologies for IoT stacks: one for resource-rich sensor nodes (Clean with iTask) and one for resource-constrained sensor nodes (Clean with iTask and mTask). The evaluation is based on four implementations of a typical smart campus application: two tierless and two Python-based tiered.(1) We show that tierless languages have the potential to significantly reduce the development effort for IoT systems, requiring 70\% less code than the tiered implementations. Careful analysis attributes this code reduction to reduced interoperation (e.g., two embedded domain-specific languages and one paradigm versus seven languages and two paradigms), automatically generated distributed communication, and powerful IoT programming abstractions. (2) We show that tierless languages have the potential to significantly improve the reliability of IoT systems, describing how Clean iTask/mTask maintains type safety, provides higher-order failure management, and simplifies maintainability. (3) We report the first comparison of a tierless IoT codebase for resource-rich sensor nodes with one for resource-constrained sensor nodes. The comparison shows that they have similar code size (within 7\%), and functional structure. (4) We present the first comparison of two tierless IoT languages, one for resource-rich sensor nodes and the other for resource-constrained sensor nodes.},
	number = {1},
	journal = {ACM Trans. Internet Things},
	author = {Lubbers, Mart and Koopman, Pieter and Ramsingh, Adrian and Singer, Jeremy and Trinder, Phil},
	month = feb,
	year = {2023},
	note = {Place: New York, NY, USA
Publisher: ACM},
	keywords = {access control, internet-of-things, IoT stacks, policy language, privilege escalation, Smart home system, Tierless languages},
	file = {Lubbers et al. - 2023 - Could Tierless Languages Reduce IoT Development Gr.pdf:/home/mrl/Zotero/storage/QD9ZBKSL/Lubbers et al. - 2023 - Could Tierless Languages Reduce IoT Development Gr.pdf:application/pdf},
}

@inproceedings{koopman_executable_2011,
	address = {Berlin, Heidelberg},
	title = {An {Executable} and {Testable} {Semantics} for {iTasks}},
	isbn = {978-3-642-24452-0},
	abstract = {The iTask system is an easy to use combinator library for specifying dynamic data dependent workflows in a very flexible way. The specified workflows are executed as a multi-user web-application. The implementation of the iTask system is fairly complicated. Hence we cannot use it for reasoning about the semantics of workflows in the iTask system. In this paper we define an executable semantics that specifies how workflows react on events generated by the workers executing them. The semantics is used to explain iTask and to reason about iTask. Based on this semantics we define a mathematical notion of equivalence of tasks and show how this equivalence for tasks can be approximated automatically. Advantages of this executable semantics are: it is easy to validate the semantics by interactive simulation; properties of the semantics can be tested by our model-based test system Gþinspace∀þinspacest. Gþinspace∀þinspacest can test a large number of properties within seconds. These tests appeared to be a good indication about the consistency of the specified semantics and equivalence relation for tasks. The automatic testing of properties was very helpful in the development of the semantics. The contribution of this paper is a semantics for iTask as well as the method used to construct this operational semantics.},
	booktitle = {Implementation and {Application} of {Functional} {Languages}},
	publisher = {Springer Berlin Heidelberg},
	author = {Koopman, Pieter and Plasmeijer, Rinus and Achten, Peter},
	editor = {Scholz, Sven-Bodo and Chitil, Olaf},
	year = {2011},
	pages = {212--232},
	file = {Koopman et al. - 2011 - An Executable and Testable Semantics for iTasks.pdf:/home/mrl/Zotero/storage/6LFA9MNU/Koopman et al. - 2011 - An Executable and Testable Semantics for iTasks.pdf:application/pdf},
}

@inproceedings{steenvoorden_tophat_2019,
	address = {New York, NY, USA},
	series = {{PPDP} '19},
	title = {{TopHat}: {A} {Formal} {Foundation} for {Task}-{Oriented} {Programming}},
	isbn = {978-1-4503-7249-7},
	url = {https://doi.org/10.1145/3354166.3354182},
	doi = {10.1145/3354166.3354182},
	abstract = {Software that models how people work is omnipresent in today's society. Current languages and frameworks often focus on usability by non-programmers, sacrificing flexibility and high level abstraction. Task-oriented programming (TOP) is a programming paradigm that aims to provide the desired level of abstraction while still being expressive enough to describe real world collaboration. It prescribes a declarative programming style to specify multi-user workflows. Workflows can be higher-order. They communicate through typed values on a local and global level. Such specifications can be turned into interactive applications for different platforms, supporting collaboration during execution. TOP has been around for more than a decade, in the forms of iTasks and mTasks, which are tailored for real-world usability. So far, it has not been given a formalisation which is suitable for formal reasoning.In this paper we give a description of the TOP paradigm and then decompose its rich features into elementary language elements, which makes them suitable for formal treatment. We use the simply typed lambda-calculus, extended with pairs and references, as a base language. On top of this language, we develop TopHat, a language for modular interactive workflows. We describe TopHat by means of a layered semantics. These layers consist of multiple big-step evaluations on expressions, and two labelled transition systems, handling user inputs.With TopHat we prepare a way to formally reason about TOP languages and programs. This approach allows for comparison with other work in the field. We have implemented the semantic rules of TopHat in Haskell, and the task layer on top of the iTasks framework. This shows that our approach is feasible, and lets us demonstrate the concepts by means of illustrative case studies. TOP has been applied in projects with the Dutch coast guard, tax office, and navy. Our work matters because formal program verification is important for mission-critical software, especially for systems with concurrency.},
	booktitle = {Proceedings of the 21st {International} {Symposium} on {Principles} and {Practice} of {Declarative} {Programming}},
	publisher = {ACM},
	author = {Steenvoorden, Tim and Naus, Nico and Klinik, Markus},
	year = {2019},
	note = {event-place: Porto, Portugal},
	file = {Steenvoorden et al. - 2019 - TopHat A Formal Foundation for Task-Oriented Prog.pdf:/home/mrl/Zotero/storage/E9W4WKZC/Steenvoorden et al. - 2019 - TopHat A Formal Foundation for Task-Oriented Prog.pdf:application/pdf},
}

@inproceedings{rosenberg_misconceptions_1997,
	address = {New York, NY, USA},
	title = {Some misconceptions about lines of code},
	doi = {10.1109/METRIC.1997.637174},
	booktitle = {Proceedings {Fourth} {International} {Software} {Metrics} {Symposium}},
	publisher = {IEEE},
	author = {Rosenberg, J.},
	year = {1997},
	note = {event-place: Albuquerque, NM, USA},
	keywords = {Arithmetic, Assembly, Code standards, Programming profession, Software engineering, Software measurement, Software quality, Standards development, Sun, Writing},
	pages = {137--142},
}
@inproceedings{alpernas_wonderful_2020,
	address = {New York, NY, USA},
	series = {Onward! 2020},
	title = {The wonderful wizard of {LoC}: paying attention to the man behind the curtain of lines-of-code metrics},
	isbn = {978-1-4503-8178-9},
	url = {https://doi.org/10.1145/3426428.3426921},
	doi = {10.1145/3426428.3426921},
	abstract = {Lines-of-code metrics (loc) are commonly reported in Programming Languages (PL), Software Engineering (SE), and Systems papers. This convention has several different, often contradictory, goals, including demonstrating the `hardness' of a problem, and demonstrating the `easiness' of a problem. In many cases, the reporting of loc metrics is done not with a clearly communicated intention, but instead in an automatic, checkbox-ticking, manner. In this paper we investigate the uses of code metrics in PL, SE, and System papers. We consider the different goals that reporting metrics aims to achieve, several various domains wherein metrics are relevant, and various alternative metrics and their pros and cons for the different goals and domains. We argue that communicating claims about research software is usually best achieved not by reporting quantitative metrics, but by reporting the qualitative experience of researchers, and propose guidelines for the cases when quantitative metrics are appropriate. We end with a case study of the one area in which lines of code are not the default measurement—code produced by papers' solutions—and identify how measurements offered are used to support an explicit claim about the algorithm. Inspired by this positive example, we call for other cogent measures to be developed to support other claims authors wish to make.},
	booktitle = {Proceedings of the 2020 {ACM} {SIGPLAN} {International} {Symposium} on {New} {Ideas}, {New} {Paradigms}, and {Reflections} on {Programming} and {Software}},
	publisher = {Association for Computing Machinery},
	author = {Alpernas, Kalev and Feldman, Yotam M. Y. and Peleg, Hila},
	year = {2020},
	note = {event-place: Virtual, USA},
	keywords = {lines of code, loc, research papers},
	pages = {146--156},
}

@inproceedings{koopman_task-based_2018,
	address = {Vienna, Austria},
	title = {A {Task}-{Based} {DSL} for {Microcomputers}},
	copyright = {All rights reserved},
	isbn = {978-1-4503-6355-6},
	url = {http://dl.acm.org/citation.cfm?doid=3183895.3183902},
	doi = {10.1145/3183895.3183902},
	abstract = {The Internet of Things, IoT, makes small connected computing devices almost omnipresent. These devices have typically very limited computing power and severe memory restrictions to make them cheap and power efficient. These devices can interact with the environment via special sensors and actuators. Since each device controls several peripherals running interleaved, the control software is quite complicated and hard to maintain. Task Oriented Programming, TOP, offers lightweight communicating threads that can inspect each other’s intermediate results. This makes it well suited for the IoT. In this paper presents a functional task-based domain specific language for these IoT devices. We show that it yields concise control programs. By restricting the datatypes and using strict evaluation these programs fit within the restrictions of microcontrollers.},
	language = {en},
	urldate = {2019-01-14},
	booktitle = {Proceedings of the {Real} {World} {Domain} {Specific} {Languages} {Workshop} 2018 on   - {RWDSL2018}},
	publisher = {ACM Press},
	author = {Koopman, Pieter and Lubbers, Mart and Plasmeijer, Rinus},
	year = {2018},
	pages = {1--11},
	file = {a4-Koopman.pdf:/home/mrl/Zotero/storage/TXZD529C/a4-Koopman.pdf:application/pdf;Koopman et al. - 2018 - A Task-Based DSL for Microcomputers.pdf:/home/mrl/Zotero/storage/9ETMTMX2/Koopman et al. - 2018 - A Task-Based DSL for Microcomputers.pdf:application/pdf},
}

@misc{lijnse_toppyt_2024,
	title = {Toppyt},
	url = {https://gitlab.com/baslijnse/toppyt},
	urldate = {2025-01-31},
	author = {Lijnse, Bas},
	year = {2024},
}

@book{stutterheim_cocktail_2017,
	address = {Nijmegen},
	title = {A {Cocktail} of {Tools}: {Domain}-{Specific} {Languages} for {Task}-{Oriented} {Software} {Development}},
	isbn = {94-92380-74-9},
	shorttitle = {A {Cocktail} of {Tools}: {DSLs} for {TOSD}},
	url = {https://hdl.handle.net/2066/181589},
	publisher = {UB Nijmegen},
	author = {Stutterheim, Jurriën},
	year = {2017},
	file = {181589.pdf:/home/mrl/Zotero/storage/RGPBE9RR/181589.pdf:application/pdf},
}

@inproceedings{brus_clean_1987,
	address = {Berlin, Heidelberg},
	title = {Clean — {A} language for functional graph rewriting},
	isbn = {978-3-540-47879-9},
	abstract = {Clean is an experimental language for specifying functional computations in terms of graph rewriting. It is based on an extension of Term Rewriting Systems (TRS) in which the terms are replaced by graphs. Such a Graph Rewriting System (GRS) consists of a, possibly cyclic, directed graph, called the data graph and graph rewrite rules which specify how this data graph may be rewritten. Clean is designed to provide a firm base for functional programming. In particular, Clean is suitable as an intermediate language between functional languages and (parallel) target machine architectures. A sequential implementation of Clean on a conventional machine is described and its performance is compared with other systems. The results show that Clean can be efficiently implemented.},
	booktitle = {Functional {Programming} {Languages} and {Computer} {Architecture}},
	publisher = {Springer Berlin Heidelberg},
	author = {Brus, T. H. and van Eekelen, M. C. J. D. and van Leer, M. O. and Plasmeijer, M. J.},
	editor = {Kahn, Gilles},
	year = {1987},
	pages = {364--384},
	file = {brut87-Clean.ps.gz:/home/mrl/Zotero/storage/T2QATWIE/brut87-Clean.ps.gz:application/gzip},
}

@misc{lubbers_clean_2024,
	title = {Clean for {Haskell} {Programmers}},
	url = {https://arxiv.org/abs/2411.00037},
	author = {Lubbers, Mart and Achten, Peter},
	year = {2024},
	note = {\_eprint: 2411.00037},
	file = {PDF:/home/mrl/Zotero/storage/8J999KYK/Lubbers and Achten - 2024 - Clean for Haskell Programmers.pdf:application/pdf},
}

@techreport{plasmeijer_clean_2021,
	address = {Nijmegen},
	title = {Clean {Language} {Report} version 3.1},
	urldate = {2021-12-22},
	institution = {Institute for Computing and Information Sciences},
	author = {Plasmeijer, Rinus and van Eekelen, Marko and van Groningen, John},
	month = dec,
	year = {2021},
	pages = {127},
	file = {CleanLanguageReport.pdf:/home/mrl/Zotero/storage/I2SDRIH6/CleanLanguageReport.pdf:application/pdf},
}
