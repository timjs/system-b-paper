\section{Introduction}

Traditionally, functional programming is known as a good paradigm to program robust complex computer systems.
Use of higher-order functions and immutable datatypes aid in modularisation and reasoning.
At the same time, because of these features, functional programming is not regarded suitable for systems programming.
Higher-order functions often involve the use of closures and
manipulating immutable datatypes involves extensive copying.
Both usually happen on the heap, making use of garbage collectors to manage memory.
In case of embedded systems, kernel modules, and hardware drivers,
these are either not available or not desirable because of memory restrictions.
It seems systems programming is out of scope for functional programming languages.

Currently, there are two ways to \cite{allow} functional languages for systems programming.
The first is to make automatic memory management deterministic by
using reference counting instead of mark-and-sweep garbage collectors.
Although this has quite some overhead at runtime,
one can minimise the amount of refcount manipulations using static analysis \cite{conf-pldi-ReinkingXML21}.
As a further optimisation, at runtime, the refcount can be used to determine if data is uniquely owned,
allowing for in-place mutation.
However, there is still the need for a heap,
which is not always available on low-level systems.

The second approach is to get rid of heap usage and garbage collectors entirely.
This requires tight type systems preventing accidental heap allocation.
Linear types can statically guarantee that every binding is used only once \cite{conf-ifip2-Wadler90,journals-pacmpl-BernardyBNJS18,journals-jfp-OConnorCRJAKMSK21}.
When using linear types only, we can be sure each binding points to uniquely owned data and modify it in-place.
However, as we will see shortly, full linear systems make it hard to program in a higher-order fashion.

\subsection{Motivation}

Take as an example below implementation to filter lists in Haskell:

\begin{BOO}
filter p xs = case xs of
  [] -> []
  x : xx -> if p x
    then x : filter p xx
    else filter p xx
\end{BOO}

When assigning a linear type to this function,
it would look something like this:

\begin{BOO}
filter :: (a -* Bool) -* List a -* List a   -- Wrong!
\end{BOO}

Here we use the lollipop arrow \texttt{-*} instead of to the normal \texttt{-\textgreater{}} arrow
to state that all parameters, \texttt{p} and \texttt{xs} in this case, are linear:
they are restricted to be used exactly once.
The pattern match on \texttt{xs} consumes the value, and makes the head \texttt{x} and tail \texttt{xx} also linearly available.

Now we immediately see a problem:
\texttt{p} needs to be applied to each element of the list and also be threaded through all calls to \texttt{filter}.
We have to make \texttt{p} available more then once,
forcing us to incorporate unrestrictedness into our type system.
Linear Haskell \cite{journals-pacmpl-BernardyBNJS18} is able to express this mixture:

\begin{BOO}
filter :: (a -* Bool) -> List a -* List a   -- Also wrong!
\end{BOO}

Now, \texttt{p} itself is unrestricted but still takes a linear argument.
This raises another problem.
On line~1, \texttt{xs} is matched linearly.
This means \texttt{x} and \texttt{xx} on line~3 are linear as well.
Therefore, the call \texttt{p\ x} on line~3 consumes \texttt{x},
so we cannot use it any more in case we want to keep the element on line~4.
To solve this, we can make \texttt{p} unrestricted in its first parameter, yielding:

\begin{BOO}
filter :: (a -> Bool) -> List a -* List a   -- Still wrong!
\end{BOO}

Again, this fix will not help us as, in general,
we cannot pass linear values to unrestricted parameters:
we cannot guarantee that \texttt{p} does not duplicate its parameter.\footnote{In this particular case, it would be hard to design a pure function returning a boolean duplicating its parameter.}
For this reason, Linear Haskell provides a \texttt{Dupable} class in its base library,
yielding the following final type for \texttt{filter} in Linear Haskell:

\begin{BOO}
filter :: Dupable a => (a -* Bool) -> List a -* List a   -- Finally fixed!
\end{BOO}

The \texttt{Dupable} constraint on \texttt{a} means we restrict \texttt{filter} to lists of types that can freely be duplicated.
So, on a type-by-type base, we need to specify that type is duplicatable.
Predicate function \texttt{p} is still passed unrestricted.

In the end, we cannot type \texttt{filter} with linear types only,
they are too restrictive.
We are forced to mix linear and shared types in our language.
On the language level, this is not a problem,
but on the implementation level this sneaks in the need for garbage collection.
Exactly this is what we hoped to prevent!

\subsection{Solution}

We propose a solution where we do not need mixing of owned and shared types.
Instead, we allow \emph{borrowing} of owned \emph{bindings}.
We introduce Boo, a small functional programming language with quantity annotations on binders.
In Boo, we can write \texttt{filter} like so:

\begin{BOO}
fun filter(1 xs: list<a>, $\textsf{ε}$ p: ($\textsf{ε}$ x: a) -> bool) -> list<a>
  match 1 xs
    Nil -> Nil
    Cons(x, xx) -> if {x| p(x) }
      then Cons(x, xx.filter(p))
      else xx.filter(p)
\end{BOO}

We see parameters in Boo are annotated with one of two \emph{quantities}:
1 for owned (affine linear) usage, and
$\textsf{ε}$ for borrowed (non-escaping) usage.
In our example, \texttt{xs} is \emph{owned}, and thus restricted to be used exactly once or not at all.
This means \texttt{xs} can be modified in-place.
Predicate function \texttt{p} and its parameter \texttt{x} are \emph{borrowed}.
Borrowed binders can be used multiple times, but cannot \emph{escape} their scope.
They are thus safe to pass on to other functions,
but cannot be returned as a result or saved in data structures.
The borrowing block \texttt{\{x\textbar{}\ p(x)\ \}} on line~4,
turns binding \texttt{x} from owned into borrowed during the evaluation of the expression \texttt{p(x)}.
Now \texttt{p} can take \texttt{x} as a borrowed parameter.

By allowing higher-order functions in Boo,
we need to take special care of the available bindings when constructing closures.
Say, we write the following code filtering a list for multiples of 3:

\begin{BOO}
val $\textsf{ε}$ m = 3
val 1 xs = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
val 1 ys = xs.filter(fn(x) x % m == 0)
// => ys == [3, 6, 9]
\end{BOO}

The lambda on line~3 closes of variable \texttt{m} from its outer scope.
As \texttt{filter} asks for a borrowed function,
we allow the construction of a borrowed lambda closing over borrowed variables.

\subsection{Contributions}

The combination of linear types and borrowing is a promising approach
to incorporate functional programming techniques like higher-order functions and immutable data types
into systems programming.
By annotating binders instead of types,
there is no stratification of linear and non-linear types.
Every type can be owned and therefore be mutated in-place, or borrowed.
Also, as borrowed values cannot escape their scope, they coincide with being second class.

In the remaining of this paper, we dive into the Boo language and its properties.
We present:

\(\lbrack\text{the language Boo, a small functional programming language with quantity annotations on binders;}\rbrack\)

\paragraph{Organisation}

The remaining of this paper is structured as follows.
In the next section, \cref{examples}, we show motivating examples of Boo,
discussing the implications of our design.
Thereafter, we formalise the syntax and semantics of Boo in \cref{theory}.
Section \cref{metatheory} contains metatheoretical properties of Boo.
After discussing related work in \cref{related-work},
we conclude and present future work in \cref{conclusion}.

\section{Examples}\label{examples}

In this section we discuss some examples to showcase the features of Boo.

\subsection{Notation}

\[\begin{aligned}
x_{0.}f\left( {\overline{{}\, x\:}}^{n} \right) & \rightsquigarrow f\left( x_{0},{\overline{{}\, x\:}}^{n} \right) \\
\text{if }e_{0}\text{ then }e_{1}\text{ else }e_{2} & \rightsquigarrow \text{ match }e_{0}\ \left\{ \text{ True } \mapsto e_{1},\text{ False } \mapsto e_{2} \right\} \\
\text{when }\left\{ e_{0} \mapsto e_{1};\text{ else } \mapsto e_{2} \right\} & \rightsquigarrow \text{ match }e_{0}\ \left\{ \text{ True } \mapsto e_{1},\text{ False } \mapsto e_{2} \right\} \\
\text{with }x_{0} \leftarrow f\left( {\overline{{}\, e\:}}^{n} \right);e_{0} & \rightsquigarrow f\left( {\overline{{}\, e\:}}^{n},|x_{0}|e_{0} \right)
\end{aligned}\]

\subsection{Simple owning and sharing functions}

\begin{BOO}
fun identity(1 x: a) -> a
  x

fun duplicate(ω x: a) -> (a, a)
  (x, x)

fun free(1 x: a) -> ()
  ()
\end{BOO}

\subsection{First-order functions on lists}

\begin{BOO}
fun length($\textsf{ε}$ xs: list<a>) -> nat
  match $\textsf{ε}$ xs
    Nil -> 0
    Cons(_, xx) -> 1 + xx.length()

fun contains($\textsf{ε}$ xs: list<a>, $\textsf{ε}$ y: a) -> bool
  match $\textsf{ε}$ xs
    Nil -> False
    Cons(x, xx) -> when
      x == y -> True
      else -> xx.contains(y)

fun append(1 xs: list<a>, 1 ys: list<a>) -> list<a>
  match 1 xs
    Nil -> ys
    Cons(x, xx) -> Cons(x, xx.append(ys))

fun dedup(1 xs: list<a>, $\textsf{ε}$ ys: list<a>) -> list<a>
  match 1 xs
    Nil -> Nil
    Cons(x, xx) -> when
      ys.contains(x) -> xx.dedup(ys)
      else -> Cons(x, xx.dedup(ys))
\end{BOO}

\subsection{Second-order functions on lists}

\begin{BOO}
fun iterate($\textsf{ε}$ xs: list<a>, $\textsf{ε}$ f: ($\textsf{ε}$ x: a) -> η ()) -> η ()
  match $\textsf{ε}$ xs
    Nil -> ()
    Cons(x, xx) ->
      f(x)
      xx.iterate(f)

fun map(1 xs: list<a>, $\textsf{ε}$ f: (1 x: a) -> η b) -> η list<b>
  match 1 xs
    Nil -> Nil
    Cons(x, xx) -> Cons(f(x), xx.map(f))

fun filter(1 xs: list<a>, $\textsf{ε}$ f: ($\textsf{ε}$ x: a) -> η bool) -> η list<a>
  match 1 xs
    Nil -> Nil
    Cons(x, xx) -> if f(x)
      then Cons(x, xx.filter(f))
      else xx.filter(f)
\end{BOO}

We'd like to invert the argument Rust makes about borrowing:
If and only if a value is used borrowed, it cannot escape the function,
and therefore it can be allocated on the stack.

\begin{BOO}
fun filter-map(1 xs: list<a>, $\textsf{ε}$ f: (1 x: a) -> η option<b>) -> η list<b>
  match 1 xs
    Nil -> Nil
    Cons(x, xx) -> match 1 f(x)
      None -> xx.filter-map(f)
      Some(y) -> Cons(y, xx.filter-map(f))
\end{BOO}

\begin{BOO}
fn retain     : (&mut Vec<a>, f: FnMut(&a)     -> bool) -> () {...}
fn retain_mut : (&mut Vec<a>, f: FnMut(&mut a) -> bool) -> () {...}
\end{BOO}

\begin{enumerate}
\item
  We can write a functional specification of this routine.
  Conceptually, we get an immutable list and build and return a new immutable list.
\item
  The list \texttt{xs} is used \emph{owned} {[}linearly, not affine, the size stays the same\ldots{]}.
  Therefore, the spine can be modified in-place if it happens to be \emph{unique} at runtime.
\item
  Every element \texttt{x} of the list is used \emph{owned} by \texttt{f}.
  Therefore, it can also be modified in-place if it is \emph{unique} at runtime.
\end{enumerate}

\section{Language and semantics}\label{theory}

\begin{figure}
\centering
\[\begin{array}{c}
{\underset{\uparrow}{{}\Gamma}\  \vdash \ \underset{\uparrow}{{}q}\  \cdot \ \underset{\uparrow}{{}e}\ :\ \underset{\downarrow}{{}\tau}\  \dashv \ \underset{\downarrow}{{}\Gamma'}} \\
{\text{Var}_{1}\ \dfrac{\text{\quad\quad}\ }{\Gamma{,\ }{{1 \cdot x}:\tau}\  \vdash \ 1\  \cdot \ x\ :\ \tau\  \dashv \ \Gamma}\ }\text{\quad\quad}{\text{Let}\ \dfrac{{\Gamma_{0}\  \vdash \ q_{0}\  \cdot \ e_{0}\ :\ \tau_{0}\  \dashv \ \Gamma_{1}}\text{\quad\quad}{\Gamma_{1}{,\ }{{q_{0} \cdot x_{0}}:\tau_{0}}\  \vdash \ q\  \cdot \ e\ :\ \tau\  \dashv \ \Gamma_{2}}}{\Gamma_{0}\  \vdash \ q\  \cdot \ {\mathsf{\mathbf{\text{val}}}^{q_{0}}\ x_{0} = e_{0};\ e}\ :\ \tau\  \dashv \ \Gamma_{2} \smallsetminus x_{0}}\ } \\
{\text{Var}_{\varepsilon}\ \dfrac{\text{\quad\quad}\ }{\Gamma{,\ }{{\varepsilon \cdot x}:\tau}\  \vdash \ \varepsilon\  \cdot \ x\ :\ \tau\  \dashv \ \Gamma{,\ }{{\varepsilon \cdot x}:\tau}}\ }\text{\quad\quad}{\text{Borrow}_{1}\ \dfrac{\text{\quad\quad}{\Gamma_{0}{,\ }{\overline{{}\,{{\varepsilon \cdot x}:\tau}\:}}^{\ast}\  \vdash \ 1\  \cdot \ e_{0}\ :\ \tau_{0}\  \dashv \ \Gamma_{1}{,\ }{\overline{{}\,{{\varepsilon \cdot x}:\tau}\:}}^{\ast}}}{\Gamma_{0}{,\ }{\overline{{}\,{{1 \cdot x}:\tau}\:}}^{\ast}\  \vdash \ q\  \cdot \ {\{{\overline{{}\, x\:}}^{\ast}\mathsf{\mathbf{\text{in}}}e_{0}\}}\ :\ \tau_{0}\  \dashv \ \Gamma_{1}{,\ }{\overline{{}\,{{1 \cdot x}:\tau}\:}}^{\ast}}\ \tau \neq \varphi} \\
{\text{Abs}_{\varepsilon}\ \dfrac{\text{\quad\quad}{\Gamma_{0}^{\varepsilon}{,\ }{\overline{{}\,{{q \cdot x}:\tau}\:}}^{n}\  \vdash \ 1\  \cdot \ e_{0}\ :\ \tau_{0}\  \dashv \ \Gamma_{1}}}{\Gamma_{0}\  \vdash \ \varepsilon\  \cdot \ {\mathsf{\mathbf{\text{fn}}}({\overline{{}\,{{q \cdot x}:\tau}\:}}^{n})\ e_{0}}\ :\ {({,\ }{\overline{{}\,{q \cdot \tau}\:}}^{n}) \rightarrow \tau_{0}}\  \dashv \ \Gamma_{0}^{1} \cup \Gamma_{1} \smallsetminus {\overline{{}\, x\:}}^{n}}\ } \\
{\text{Abs}_{1}\ \dfrac{\text{\quad\quad}{\Gamma_{0}^{1}{,\ }{\overline{{}\,{{q \cdot x}:\tau}\:}}^{n}\  \vdash \ 1\  \cdot \ e_{0}\ :\ \tau_{0}\  \dashv \ \Gamma_{1}}}{\Gamma_{0}\  \vdash \ 1\  \cdot \ {\mathsf{\mathbf{\text{fn}}}({\overline{{}\,{{q \cdot x}:\tau}\:}}^{n})\ e_{0}}\ :\ {({,\ }{\overline{{}\,{q \cdot \tau}\:}}^{n}) \rightarrow \tau_{0}}\  \dashv \ \Gamma_{0}^{\varepsilon} \cup \Gamma_{1} \smallsetminus {\overline{{}\, x\:}}^{n}}\ } \\
{\text{App}\ \dfrac{{\Gamma_{0}\  \vdash \ \varepsilon\  \cdot \ e_{0}\ :\ {({,\ }{\overline{{}\,{q \cdot \tau}\:}}^{n}) \rightarrow \tau_{0}}\  \dashv \ \Gamma_{1}}\text{\quad\quad}{\Gamma_{0} \cap \Gamma_{1}\  \Vdash \ {\overline{{}\, q\:}}^{n}\  \cdot \ {\overline{{}\, e\:}}^{n}\ :\ {\overline{{}\,\tau\:}}^{n}\  \Vdash \ \Gamma_{n + 1}}}{\Gamma_{0}\  \vdash \ q\  \cdot \ {e_{0}({\overline{{}\, e\:}}^{n})}\ :\ \tau_{0}\  \dashv \ \Gamma_{n + 1}}\ } \\
{\text{Construct}\ \dfrac{{\Delta\  \vdash \ C\ :\ {({,\ }{\overline{{}\,\tau\:}}^{n}) \rightarrow \tau_{0}}}\text{\quad\quad}{\Gamma_{1}\  \Vdash \ q\  \cdot \ {\overline{{}\, e\:}}^{n}\ :\ {\overline{{}\,\tau\:}}^{n}\  \Vdash \ \Gamma_{n + 1}}}{\Gamma_{1}\  \vdash \ q\  \cdot \ {C({\overline{{}\, e\:}}^{n})}\ :\ \tau_{0}\  \dashv \ \Gamma_{n + 1}}\ } \\
{\text{Match}\ \dfrac{{\Gamma_{0}\  \vdash \ q_{0}\  \cdot \ e_{0}\ :\ \tau_{0}\  \dashv \ \Gamma'_{0}}\text{\quad\quad}{\text{for each }i \in 1..m}\text{\quad\quad}{\Delta\  \vdash \ C_{i}\ :\ {({,\ }{\overline{{}\,\tau\:}}^{n_{i}}) \rightarrow \tau_{0}}}\text{\quad\quad}{\Gamma'_{0}{,\ }{\overline{{}\,{{q_{0} \cdot x}:\tau}\:}}^{n_{i}}\  \vdash \ q\  \cdot \ e_{i}\ :\ \tau_{i}\  \dashv \ \Gamma_{i}}}{\Gamma_{0}\  \vdash \ q\  \cdot \ {\mathsf{\mathbf{\text{match}}}^{q_{0}}\ e_{0}\ \{{\overline{{}\,{C({\overline{{}\, x\:}}^{n})} \mapsto e\:}}^{m}\}}\ :\ \tau\  \dashv \  \cap_{i \in 1..m}\Gamma_{i}}\ \text{ same}({\overline{{}\,\tau\:}}^{m})}
\end{array}\]
\caption{Synthesizing type rules for Boo}
\end{figure}

\begin{figure}
\centering
\[\begin{array}{c}
{\underset{\uparrow}{{}\Gamma}\  \Vdash \ \underset{\uparrow}{{}{\overline{{}\, q\:}}^{n}}\  \cdot \ \underset{\uparrow}{{}{\overline{{}\, e\:}}^{n}}\ :\ \underset{\uparrow}{{}{\overline{{}\,\tau\:}}^{n}}\  \Vdash \ \underset{\downarrow}{{}\Gamma'}} \\
{\text{Empty}\ \dfrac{}{\Gamma_{0}\  \Vdash \ {\lbrack\rbrack}\  \cdot \ {\lbrack\rbrack}\ :\ {\lbrack\rbrack}\  \Vdash \ \Gamma_{0}}\ }\text{\quad\quad}{\text{Rest}\ \dfrac{{\Gamma_{0}\  \vdash \ q_{0}\  \cdot \ e_{0}\ :\ \tau_{0}'\  \dashv \ \Gamma_{1}}\text{\quad\quad}\tau_{0}' \equiv \tau_{0}\text{\quad\quad}{\Gamma_{0} \cap \Gamma_{1}\  \Vdash \ {\overline{{}\, q\:}}^{n}\  \cdot \ {\overline{{}\, e\:}}^{n}\ :\ {\overline{{}\,\tau\:}}^{n}\  \Vdash \ \Gamma_{n + 1}}}{\Gamma_{0}\  \Vdash \ q_{0}{,\ }{\overline{{}\, q\:}}^{n}\  \cdot \ e_{0}{,\ }{\overline{{}\, e\:}}^{n}\ :\ \tau_{0}{,\ }{\overline{{}\,\tau\:}}^{n}\  \Vdash \ \Gamma_{n + 1}}\ }
\end{array}\]
\caption{Spine typing rules for Boo}
\end{figure}

\section{Adding unrestrictedness}

\section{Guarantees}\label{metatheory}

\section{Related work}\label{related-work}

\section{Conclusion}\label{conclusion}

\subsection{Future work}
