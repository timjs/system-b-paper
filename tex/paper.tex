\section{Introduction}

\paragraph{Context}

Traditionally, functional programming is known as a good method for designing complex computer systems.
Use of higher-order functions and immutable datatypes aid in modularisation and reasoning.
Because of the same features, functional programming is not regarded suitable for systems programming.
Higher-order functions often involve the use of closures.
Manipulating immutable datatypes involves extensive copying.
Both usually happen on the heap, making use of garbage collectors to manage memory.
These are either not available or not desirable because of memory restrictions.

\paragraph{Challenges}

Currently, there are two ways to allow functional languages for systems programming.
The first is to use reference counting instead of mark-and-sweep garbage collectors.
Although this has quite some overhead at runtime,
deallocation times become deterministic and
one can minimise the amount of refcount manipulations using static analysis {[}conf-pldi-ReinkingXML21{]}.
As a further optimisation, at runtime, the refcount can be used to determine if data is uniquely owned,
allowing for in-place mutation.
However, there is still the need for a heap,
which is not always available on low-level systems.

The second approach is to get rid of heap usage and garbage collectors entirely.
To do this, we need a tight type system preventing us from accidental heap allocation.
Examples are full linear type systems {[}conf-ifip2-Wadler90{]}{[}journals-pacmpl-BernardyBNJS18{]}{[}journals-jfp-OConnorCRJAKMSK21{]}
which statically guarantee that every binding is used only once.
When using linear types only, we can be sure each binding points to uniquely owned data and modify it in-place.
Other languages, like Clean {[}plasmeijer2002clean{]}, use uniqueness types additional to shared types
for ensured in-place updates or unique state threading.

\paragraph{Motivation}

Full linear systems, however, make it hard to program in a higher-order fashion.
Take as an example the \texttt{filter} function on lists, in Haskell syntax:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{filter}\NormalTok{ f xs }\OtherTok{=} \KeywordTok{case}\NormalTok{ xs }\KeywordTok{of}
\NormalTok{  [] }\OtherTok{{-}\textgreater{}}\NormalTok{ []}
\NormalTok{  x }\OperatorTok{:}\NormalTok{ xx }\OtherTok{{-}\textgreater{}} \KeywordTok{if}\NormalTok{ f x}
    \KeywordTok{then}\NormalTok{ x }\OperatorTok{:} \FunctionTok{filter}\NormalTok{ f xx}
    \KeywordTok{else} \FunctionTok{filter}\NormalTok{ f xx}
\end{Highlighting}
\end{Shaded}

When assigning a linear type to this function,
it would look something like this:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{filter}\OtherTok{ ::}\NormalTok{ (a }\OperatorTok{{-}*} \DataTypeTok{Bool}\NormalTok{) }\OperatorTok{{-}*} \DataTypeTok{List}\NormalTok{ a }\OperatorTok{{-}*} \DataTypeTok{List}\NormalTok{ a   }\CommentTok{{-}{-} Wrong!}
\end{Highlighting}
\end{Shaded}

Here we use the lollipop arrow \texttt{-*} instead of to the normal \texttt{-\textgreater{}} arrow
to state that all parameters, \texttt{f} and \texttt{xs} in this case, are linear:
they are restricted to be used exactly once.
The pattern match on \texttt{xs} consumes the value, and makes the head \texttt{x} and tail \texttt{xx} also linearly available.

Now we immediately see a problem:
\texttt{f} needs to be applied to each element of the list and also be threaded through all calls to \texttt{filter}.
We have to make \texttt{f} available more then once,
forcing us to incorporate unrestrictedness into our type system.
This sneaks in the need for garbage collection in our language implementation
and stratifies our language with functions for linear and unrestricted usage.
Linear Haskell {[}journals-pacmpl-BernardyBNJS18{]} is able to express this mixture:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{filter}\OtherTok{ ::}\NormalTok{ (a }\OperatorTok{{-}*} \DataTypeTok{Bool}\NormalTok{) }\OtherTok{{-}\textgreater{}} \DataTypeTok{List}\NormalTok{ a }\OperatorTok{{-}*} \DataTypeTok{List}\NormalTok{ a   }\CommentTok{{-}{-} Also wrong!}
\end{Highlighting}
\end{Shaded}

Now, \texttt{f} itself is unrestricted but still takes a linear argument.
This raises another problem.
On line~1, \texttt{xs} is matched linearly.
This means \texttt{x} and \texttt{xx} on line~3 are linear as well.
Therefore, the call \texttt{f\ x} on line~3 consumes \texttt{x},
so we cannot use it any more in case we want to keep the element on line~4.
To solve this, we can make \texttt{f} unrestricted in its first parameter, yielding:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{filter}\OtherTok{ ::}\NormalTok{ (a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Bool}\NormalTok{) }\OtherTok{{-}\textgreater{}} \DataTypeTok{List}\NormalTok{ a }\OperatorTok{{-}*} \DataTypeTok{List}\NormalTok{ a   }\CommentTok{{-}{-} Still wrong!}
\end{Highlighting}
\end{Shaded}

Again, this fix will not help us as, in general,
we cannot pass a linear value as an unrestricted parameter.
In this case, we cannot guarantee that \texttt{f} does not duplicate its parameter.\footnote{In this particular case, it would be hard to design a pure function returning a boolean duplicating its parameter.}
For this reason, Linear Haskell provides a \texttt{Dupable} class in its base library,
yielding the following type for \texttt{filter} in Linear Haskell:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{filter}\OtherTok{ ::} \DataTypeTok{Dupable}\NormalTok{ a }\OtherTok{=\textgreater{}}\NormalTok{ (a }\OperatorTok{{-}*} \DataTypeTok{Bool}\NormalTok{) }\OtherTok{{-}\textgreater{}} \DataTypeTok{List}\NormalTok{ a }\OperatorTok{{-}*} \DataTypeTok{List}\NormalTok{ a   }\CommentTok{{-}{-} Finally fixed!}
\end{Highlighting}
\end{Shaded}

The \texttt{Dupable} constraint on \texttt{a} means we restrict \texttt{filter} to lists of types that can freely be duplicated.
So, on a type-by-type base, we need to specify that type is dupable.
Note predicate function \texttt{f} is still passed unrestricted.

\paragraph{Solution}

We propose a different solution,
where we do not need mixing owned and shared types.
Instead, we allow \emph{borrowing} of owned values.
In Boo, we can write \texttt{filter} like so, using a Koka-like syntax:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fun filter(1 xs: list\textless{}a\textgreater{}, ε f: (ε x: a) {-}\textgreater{} bool) {-}\textgreater{} list\textless{}a\textgreater{}}
\NormalTok{  match 1 xs}
\NormalTok{    Nil {-}\textgreater{} Nil}
\NormalTok{    Cons(x, xx) {-}\textgreater{} if \{x| f(x) \}}
\NormalTok{      then Cons(x, xx.filter(f))}
\NormalTok{      else xx.filter(f)}
\end{Highlighting}
\end{Shaded}

In Boo, we annotate the binders with one of two \emph{quantities}:
1 for owned (affine linear) usage, and
ε for borrowed (non-escaping) usage.
In our example, \texttt{xs} is \emph{owned}, and thus restricted to be used exactly once or not at all.
This means \texttt{xs} can be modified in-place.
Predicate function \texttt{f} and its parameter \texttt{x} are \emph{borrowed}.
Borrowed binders can be used multiple times, but cannot \emph{escape} their scope.
They are thus safe to pass on to other functions,
but cannot be returned as a result or saved in data structures.

The borrowing block \texttt{\{x\textbar{}\ f(x)\ \}} on line~4,
turns binding \texttt{x} from owned into borrowed during the evaluation of the expression \texttt{f(x)}.
Now \texttt{f} can take \texttt{x} as a borrowed parameter.

By allowing higher-order functions in Boo,
we need to take special care of the available bindings when constructing closures.
Say, we write the following code filtering a list for multiples of 3:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{val ε m = 3}
\NormalTok{val 1 xs = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]}
\NormalTok{val 1 ys = xs.filter(fn(x) x \% m == 0)}
\NormalTok{// =\textgreater{} ys == [3, 6, 9]}
\end{Highlighting}
\end{Shaded}

The lambda on line~3 closes of variable \texttt{m} from its outer scope.
As \texttt{filter} asks for a borrowed function,
we allow the construction of a borrowed lambda closing over borrowed variables.

\paragraph{Contributions}

In the remaining of this paper, we dive into the Boo language and its properties.
We present:

\(\lbrack\text{the language Boo,
a small functional programming language with quantity annotations on the binders;}\rbrack\)

\paragraph{Organisation}

The remaining of this paper is structured as follows.
In the next section, \hyperref[examples]{{[}examples{]}}, we show motivating examples of Boo,
discussing the implications of our design.
Thereafter, we formalise the syntax and semantics of Boo in \hyperref[theory]{{[}theory{]}}.
Section \hyperref[metatheory]{{[}metatheory{]}} contains metatheoretical properties of Boo.
After discussing related work in \hyperref[related-work]{{[}related-work{]}},
we conclude and present future work in \hyperref[conclusion]{{[}conclusion{]}}.

\section{Examples}\label{examples}

In this section we discuss some examples to showcase the features of Boo.

\subsection{Notation}

\[\begin{aligned}
x_{0.}f\left( {\overline{{}\, x\:}}^{n} \right) & \rightsquigarrow f\left( x_{0},{\overline{{}\, x\:}}^{n} \right) \\
\text{if }e_{0}\text{ then }e_{1}\text{ else }e_{2} & \rightsquigarrow \text{ match }e_{0}\ \left\{ \text{ True } \mapsto e_{1},\text{ False } \mapsto e_{2} \right\} \\
\text{when }\left\{ e_{0} \mapsto e_{1};\text{ else } \mapsto e_{2} \right\} & \rightsquigarrow \text{ match }e_{0}\ \left\{ \text{ True } \mapsto e_{1},\text{ False } \mapsto e_{2} \right\} \\
\text{with }x_{0} \leftarrow f\left( {\overline{{}\, e\:}}^{n} \right);e_{0} & \rightsquigarrow f\left( {\overline{{}\, e\:}}^{n},|x_{0}|e_{0} \right)
\end{aligned}\]

\subsection{Simple owning and sharing functions}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fun identity(1 x: a) {-}\textgreater{} a}
\NormalTok{  x}

\NormalTok{fun duplicate(ω x: a) {-}\textgreater{} (a, a)}
\NormalTok{  (x, x)}

\NormalTok{fun free(1 x: a) {-}\textgreater{} ()}
\NormalTok{  ()}
\end{Highlighting}
\end{Shaded}

\subsection{First-order functions on lists}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fun length(ε xs: list\textless{}a\textgreater{}) {-}\textgreater{} nat}
\NormalTok{  match ε xs}
\NormalTok{    Nil {-}\textgreater{} 0}
\NormalTok{    Cons(\_, xx) {-}\textgreater{} 1 + xx.length()}

\NormalTok{fun contains(ε xs: list\textless{}a\textgreater{}, ε y: a) {-}\textgreater{} bool}
\NormalTok{  match ε xs}
\NormalTok{    Nil {-}\textgreater{} False}
\NormalTok{    Cons(x, xx) {-}\textgreater{} when}
\NormalTok{      x == y {-}\textgreater{} True}
\NormalTok{      else {-}\textgreater{} xx.contains(y)}

\NormalTok{fun append(1 xs: list\textless{}a\textgreater{}, 1 ys: list\textless{}a\textgreater{}) {-}\textgreater{} list\textless{}a\textgreater{}}
\NormalTok{  match 1 xs}
\NormalTok{    Nil {-}\textgreater{} ys}
\NormalTok{    Cons(x, xx) {-}\textgreater{} Cons(x, xx.append(ys))}

\NormalTok{fun dedup(1 xs: list\textless{}a\textgreater{}, ε ys: list\textless{}a\textgreater{}) {-}\textgreater{} list\textless{}a\textgreater{}}
\NormalTok{  match 1 xs}
\NormalTok{    Nil {-}\textgreater{} Nil}
\NormalTok{    Cons(x, xx) {-}\textgreater{} when}
\NormalTok{      ys.contains(x) {-}\textgreater{} xx.dedup(ys)}
\NormalTok{      else {-}\textgreater{} Cons(x, xx.dedup(ys))}
\end{Highlighting}
\end{Shaded}

\subsection{Second-order functions on lists}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fun iterate(ε xs: list\textless{}a\textgreater{}, ε f: (ε x: a) {-}\textgreater{} η ()) {-}\textgreater{} η ()}
\NormalTok{  match ε xs}
\NormalTok{    Nil {-}\textgreater{} ()}
\NormalTok{    Cons(x, xx) {-}\textgreater{}}
\NormalTok{      f(x)}
\NormalTok{      xx.iterate(f)}

\NormalTok{fun map(1 xs: list\textless{}a\textgreater{}, ε f: (1 x: a) {-}\textgreater{} η b) {-}\textgreater{} η list\textless{}b\textgreater{}}
\NormalTok{  match 1 xs}
\NormalTok{    Nil {-}\textgreater{} Nil}
\NormalTok{    Cons(x, xx) {-}\textgreater{} Cons(f(x), xx.map(f))}

\NormalTok{fun filter(1 xs: list\textless{}a\textgreater{}, ε f: (ε x: a) {-}\textgreater{} η bool) {-}\textgreater{} η list\textless{}a\textgreater{}}
\NormalTok{  match 1 xs}
\NormalTok{    Nil {-}\textgreater{} Nil}
\NormalTok{    Cons(x, xx) {-}\textgreater{} if f(x)}
\NormalTok{      then Cons(x, xx.filter(f))}
\NormalTok{      else xx.filter(f)}
\end{Highlighting}
\end{Shaded}

We'd like to invert the argument Rust makes about borrowing:
If and only if a value is used borrowed, it cannot escape the function,
and therefore it can be allocated on the stack.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fun filter{-}map(1 xs: list\textless{}a\textgreater{}, ε f: (1 x: a) {-}\textgreater{} η option\textless{}b\textgreater{}) {-}\textgreater{} η list\textless{}b\textgreater{}}
\NormalTok{  match 1 xs}
\NormalTok{    Nil {-}\textgreater{} Nil}
\NormalTok{    Cons(x, xx) {-}\textgreater{} match 1 f(x)}
\NormalTok{      None {-}\textgreater{} xx.filter{-}map(f)}
\NormalTok{      Some(y) {-}\textgreater{} Cons(y, xx.filter{-}map(f))}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn}\NormalTok{ retain     : (}\OperatorTok{\&}\KeywordTok{mut} \DataTypeTok{Vec}\OperatorTok{\textless{}}\NormalTok{a}\OperatorTok{\textgreater{},}\NormalTok{ f}\OperatorTok{:} \BuiltInTok{FnMut}\NormalTok{(}\OperatorTok{\&}\NormalTok{a)     }\OperatorTok{{-}\textgreater{}} \DataTypeTok{bool}\NormalTok{) }\OperatorTok{{-}\textgreater{}}\NormalTok{ () }\OperatorTok{\{...\}}
\KeywordTok{fn}\NormalTok{ retain\_mut : (}\OperatorTok{\&}\KeywordTok{mut} \DataTypeTok{Vec}\OperatorTok{\textless{}}\NormalTok{a}\OperatorTok{\textgreater{},}\NormalTok{ f}\OperatorTok{:} \BuiltInTok{FnMut}\NormalTok{(}\OperatorTok{\&}\KeywordTok{mut}\NormalTok{ a) }\OperatorTok{{-}\textgreater{}} \DataTypeTok{bool}\NormalTok{) }\OperatorTok{{-}\textgreater{}}\NormalTok{ () }\OperatorTok{\{...\}}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\item
  We can write a functional specification of this routine.
  Conceptually, we get an immutable list and build and return a new immutable list.
\item
  The list \texttt{xs} is used \emph{owned} {[}linearly, not affine, the size stays the same\ldots{]}.
  Therefore, the spine can be modified in-place if it happens to be \emph{unique} at runtime.
\item
  Every element \texttt{x} of the list is used \emph{owned} by \texttt{f}.
  Therefore, it can also be modified in-place if it is \emph{unique} at runtime.
\end{enumerate}

\section{Language and semantics}\label{theory}

\begin{figure}
\centering
\[\begin{array}{c}
{\underset{\uparrow}{{}\Gamma}\  \vdash \ \underset{\uparrow}{{}q}\  \cdot \ \underset{\uparrow}{{}e}\ :\ \underset{\downarrow}{{}\tau}\  \dashv \ \underset{\downarrow}{{}\Gamma'}} \\
{\text{Var}_{1}\ \dfrac{\text{\quad\quad}\ }{\Gamma{,\ }{{1 \cdot x}:\tau}\  \vdash \ 1\  \cdot \ x\ :\ \tau\  \dashv \ \Gamma}\ }\text{\quad\quad}{\text{Let}\ \dfrac{{\Gamma_{0}\  \vdash \ q_{0}\  \cdot \ e_{0}\ :\ \tau_{0}\  \dashv \ \Gamma_{1}}\text{\quad\quad}{\Gamma_{1}{,\ }{{q_{0} \cdot x_{0}}:\tau_{0}}\  \vdash \ q\  \cdot \ e\ :\ \tau\  \dashv \ \Gamma_{2}}}{\Gamma_{0}\  \vdash \ q\  \cdot \ {\mathsf{\mathbf{\text{val}}}^{q_{0}}\ x_{0} = e_{0};\ e}\ :\ \tau\  \dashv \ \Gamma_{2} \smallsetminus x_{0}}\ } \\
{\text{Var}_{\varepsilon}\ \dfrac{\text{\quad\quad}\ }{\Gamma{,\ }{{\varepsilon \cdot x}:\tau}\  \vdash \ \varepsilon\  \cdot \ x\ :\ \tau\  \dashv \ \Gamma{,\ }{{\varepsilon \cdot x}:\tau}}\ }\text{\quad\quad}{\text{Borrow}_{1}\ \dfrac{\text{\quad\quad}{\Gamma_{0}{,\ }{\overline{{}\,{{\varepsilon \cdot x}:\tau}\:}}^{\ast}\  \vdash \ 1\  \cdot \ e_{0}\ :\ \tau_{0}\  \dashv \ \Gamma_{1}{,\ }{\overline{{}\,{{\varepsilon \cdot x}:\tau}\:}}^{\ast}}}{\Gamma_{0}{,\ }{\overline{{}\,{{1 \cdot x}:\tau}\:}}^{\ast}\  \vdash \ q\  \cdot \ {\{{\overline{{}\, x\:}}^{\ast}\mathsf{\mathbf{\text{in}}}e_{0}\}}\ :\ \tau_{0}\  \dashv \ \Gamma_{1}{,\ }{\overline{{}\,{{1 \cdot x}:\tau}\:}}^{\ast}}\ \tau \neq \varphi} \\
{\text{Abs}_{\varepsilon}\ \dfrac{\text{\quad\quad}{\Gamma_{0}^{\varepsilon}{,\ }{\overline{{}\,{{q \cdot x}:\tau}\:}}^{n}\  \vdash \ 1\  \cdot \ e_{0}\ :\ \tau_{0}\  \dashv \ \Gamma_{1}}}{\Gamma_{0}\  \vdash \ \varepsilon\  \cdot \ {\mathsf{\mathbf{\text{fn}}}({\overline{{}\,{{q \cdot x}:\tau}\:}}^{n})\ e_{0}}\ :\ {({,\ }{\overline{{}\,{q \cdot \tau}\:}}^{n}) \rightarrow \tau_{0}}\  \dashv \ \Gamma_{0}^{1} \cup \Gamma_{1} \smallsetminus {\overline{{}\, x\:}}^{n}}\ } \\
{\text{Abs}_{1}\ \dfrac{\text{\quad\quad}{\Gamma_{0}^{1}{,\ }{\overline{{}\,{{q \cdot x}:\tau}\:}}^{n}\  \vdash \ 1\  \cdot \ e_{0}\ :\ \tau_{0}\  \dashv \ \Gamma_{1}}}{\Gamma_{0}\  \vdash \ 1\  \cdot \ {\mathsf{\mathbf{\text{fn}}}({\overline{{}\,{{q \cdot x}:\tau}\:}}^{n})\ e_{0}}\ :\ {({,\ }{\overline{{}\,{q \cdot \tau}\:}}^{n}) \rightarrow \tau_{0}}\  \dashv \ \Gamma_{0}^{\varepsilon} \cup \Gamma_{1} \smallsetminus {\overline{{}\, x\:}}^{n}}\ } \\
{\text{App}\ \dfrac{{\Gamma_{0}\  \vdash \ \varepsilon\  \cdot \ e_{0}\ :\ {({,\ }{\overline{{}\,{q \cdot \tau}\:}}^{n}) \rightarrow \tau_{0}}\  \dashv \ \Gamma_{1}}\text{\quad\quad}{\Gamma_{0} \cap \Gamma_{1}\  \Vdash \ {\overline{{}\, q\:}}^{n}\  \cdot \ {\overline{{}\, e\:}}^{n}\ :\ {\overline{{}\,\tau\:}}^{n}\  \Vdash \ \Gamma_{n + 1}}}{\Gamma_{0}\  \vdash \ q\  \cdot \ {e_{0}({\overline{{}\, e\:}}^{n})}\ :\ \tau_{0}\  \dashv \ \Gamma_{n + 1}}\ } \\
{\text{Construct}\ \dfrac{{\Delta\  \vdash \ C\ :\ {({,\ }{\overline{{}\,\tau\:}}^{n}) \rightarrow \tau_{0}}}\text{\quad\quad}{\Gamma_{1}\  \Vdash \ q\  \cdot \ {\overline{{}\, e\:}}^{n}\ :\ {\overline{{}\,\tau\:}}^{n}\  \Vdash \ \Gamma_{n + 1}}}{\Gamma_{1}\  \vdash \ q\  \cdot \ {C({\overline{{}\, e\:}}^{n})}\ :\ \tau_{0}\  \dashv \ \Gamma_{n + 1}}\ } \\
{\text{Match}\ \dfrac{{\Gamma_{0}\  \vdash \ q_{0}\  \cdot \ e_{0}\ :\ \tau_{0}\  \dashv \ \Gamma'_{0}}\text{\quad\quad}{\text{for each }i \in 1..m}\text{\quad\quad}{\Delta\  \vdash \ C_{i}\ :\ {({,\ }{\overline{{}\,\tau\:}}^{n_{i}}) \rightarrow \tau_{0}}}\text{\quad\quad}{\Gamma'_{0}{,\ }{\overline{{}\,{{q_{0} \cdot x}:\tau}\:}}^{n_{i}}\  \vdash \ q\  \cdot \ e_{i}\ :\ \tau_{i}\  \dashv \ \Gamma_{i}}}{\Gamma_{0}\  \vdash \ q\  \cdot \ {\mathsf{\mathbf{\text{match}}}^{q_{0}}\ e_{0}\ \{{\overline{{}\,{C({\overline{{}\, x\:}}^{n})} \mapsto e\:}}^{m}\}}\ :\ \tau\  \dashv \  \cap_{i \in 1..m}\Gamma_{i}}\ \text{ same}({\overline{{}\,\tau\:}}^{m})}
\end{array}\]
\caption{Synthesizing type rules for Boo}
\end{figure}

\begin{figure}
\centering
\[\begin{array}{c}
{\underset{\uparrow}{{}\Gamma}\  \Vdash \ \underset{\uparrow}{{}{\overline{{}\, q\:}}^{n}}\  \cdot \ \underset{\uparrow}{{}{\overline{{}\, e\:}}^{n}}\ :\ \underset{\uparrow}{{}{\overline{{}\,\tau\:}}^{n}}\  \Vdash \ \underset{\downarrow}{{}\Gamma'}} \\
{\text{Empty}\ \dfrac{}{\Gamma_{0}\  \Vdash \ {\lbrack\rbrack}\  \cdot \ {\lbrack\rbrack}\ :\ {\lbrack\rbrack}\  \Vdash \ \Gamma_{0}}\ }\text{\quad\quad}{\text{Rest}\ \dfrac{{\Gamma_{0}\  \vdash \ q_{0}\  \cdot \ e_{0}\ :\ \tau_{0}'\  \dashv \ \Gamma_{1}}\text{\quad\quad}\tau_{0}' \equiv \tau_{0}\text{\quad\quad}{\Gamma_{0} \cap \Gamma_{1}\  \Vdash \ {\overline{{}\, q\:}}^{n}\  \cdot \ {\overline{{}\, e\:}}^{n}\ :\ {\overline{{}\,\tau\:}}^{n}\  \Vdash \ \Gamma_{n + 1}}}{\Gamma_{0}\  \Vdash \ q_{0}{,\ }{\overline{{}\, q\:}}^{n}\  \cdot \ e_{0}{,\ }{\overline{{}\, e\:}}^{n}\ :\ \tau_{0}{,\ }{\overline{{}\,\tau\:}}^{n}\  \Vdash \ \Gamma_{n + 1}}\ }
\end{array}\]
\caption{Spine typing rules for Boo}
\end{figure}

\section{Adding unrestrictedness}

\section{Guarantees}\label{metatheory}

\section{Related work}\label{related-work}

\section{Conclusion}\label{conclusion}

\subsection{Future work}
